"""
Make images from binaries.
Resizes binaries that are not the correct shape, padding zeros where necessary.
"""
from math import ceil, sqrt
import multiprocessing
import os
import re
import time
from typing import List

# pylint: disable=import-error
import cv2
import numpy as np

# Global variables for input and output directories
INPUT_DIR1 = "dataset/malicious"
INPUT_DIR2 = "dataset/benign"
OUTPUT_DIR1 = "features/malicious"
OUTPUT_DIR2 = "features/benign"

# Replace it with `None` for all files
MAX_NUM_FILE_TYPE = 1200
# Channels must be either 1 (grayscale) or 3 (RGB)
CHANNELS = 3
# Side length of resulting square images
SIDE_LENGTH = 1024
# Max scale factor for larger binaries
MAX_SCALE_FACTOR = 4


def create_output_directories() -> None:
    """
    Creates the output directories if they do not already exist.
    """
    os.makedirs(OUTPUT_DIR1, exist_ok=True)
    os.makedirs(OUTPUT_DIR2, exist_ok=True)


def find_exe_files(directory: str) -> List[str]:
    """
    Finds all .exe files in the specified directory
    :param directory: The directory path to search in.
    :returns: A list of full paths to the .exe files found.
    """
    exe_pattern = re.compile(r".*\.exe$", re.IGNORECASE)  # Regex to match .exe files

    # Using scandir and list comprehension to collect .exe files
    exe_files = [
        entry.path for entry in os.scandir(directory)
        if entry.is_file() and os.path.getsize(entry.path) > 500 and
           (exe_pattern.match(entry.name) or len(entry.path) > 60)
    ]

    return exe_files


def make_image(input_path: str, output_path: str, side_length: int, channels: int) -> None:
    """
    Convert an input binary into an image of specified size.
    :param input_path: Path to the input binary.
    :param output_path: Path of the output image.
    :param side_length: The length of the resulting square image's sides.
    :param channels: Use 1 for grayscale and 3 for RGB.
    :return: None
    """
    assert channels in (1, 3), "Channels must be either 1 (grayscale) or 3 (RGB)"
    assert side_length > 1, "Side length must be positive"

    # Read the data as *serial* bytes (uint8)
    data: np.ndarray = np.fromfile(input_path, dtype=np.uint8)
    # Matrix/Image of shape (side_length, side_length, channels)
    result_len = side_length ** 2 * channels

    # Truncate binaries that are too large
    data = data[:result_len * MAX_SCALE_FACTOR]
    # Find the prescaling side length
    temp_side_len = ceil(sqrt(len(data) / channels))
    # Pad for resizing
    data = np.pad(data, pad_width=(0, (temp_side_len ** 2 * channels) - len(data)))

    # Make the binary image shaped
    if channels == 1:
        data = np.reshape(data, (temp_side_len, temp_side_len))
    else:
        data = np.reshape(data, (temp_side_len, temp_side_len, channels))

    # Convert to BGR and scale the image to be correct
    # pylint: disable=no-member
    data = cv2.resize(
        cv2.cvtColor(
            data,
            cv2.COLOR_RGB2BGR
        ),
        (side_length, side_length),
        interpolation=cv2.INTER_LANCZOS4
    )
    cv2.imwrite(output_path, data)

    # Save some memory for parallel execution
    del data


def process_list(sub_file_list: List[str], out_dir: str, side_length: int, channels: int) -> None:
    """
    Target function for multiprocessing worker. Calls make_image in each file in `sub_file_list`.
    :param sub_file_list: The list of executable files to convert into images.
    :param out_dir: The directory to place the output images in.
    :param side_length: The side length of the resulting images.
    :param channels: Should be either 1 or 3 for grayscale and RGB respectively.
    :return: None
    """
    for file_path in sub_file_list:
        make_image(
            file_path,
            out_dir + file_path[file_path.rfind(os.path.sep):file_path.rfind(".")] + ".png",
            side_length,
            channels
        )


if __name__ == "__main__":
    # Ensure output directories are created
    create_output_directories()

    # Find all .exe files in the input directories
    input_file_list_a = find_exe_files(INPUT_DIR1)
    input_file_list_b = find_exe_files(INPUT_DIR2)

    if MAX_NUM_FILE_TYPE is not None:
        input_file_list_a = input_file_list_a[:MAX_NUM_FILE_TYPE]
        input_file_list_b = input_file_list_b[:MAX_NUM_FILE_TYPE]

    # Print the found .exe files from each directory
    print(f"Found {len(input_file_list_a)} .exe files in {INPUT_DIR1}\n"
          f"Found {len(input_file_list_b)} .exe files in {INPUT_DIR2}")

    # Process initialization
    num_processes = multiprocessing.cpu_count()
    # I'm not using `with` here because I've never managed to get it to work correctly
    # pylint: disable=consider-using-with
    pool = multiprocessing.Pool(processes=num_processes)

    print("Separating work for threads")
    # Split the work to divide to the threads
    split_file_list_a = [
        input_file_list_a[i:i + num_processes]
        for i in range(0, len(input_file_list_a), num_processes)
    ]
    split_file_list_b = [
        input_file_list_b[i:i + num_processes]
        for i in range(0, len(input_file_list_b), num_processes)
    ]

    start = time.perf_counter()
    print("Sending work to threads")
    # Add the work to the pool
    for sub_list in split_file_list_a:
        pool.apply_async(process_list, args=(sub_list, OUTPUT_DIR1, SIDE_LENGTH, CHANNELS))
        # process_list(sub_list, OUTPUT_DIR1, SIDE_LENGTH, CHANNELS)
    for sub_list in split_file_list_b:
        pool.apply_async(process_list, args=(sub_list, OUTPUT_DIR2, SIDE_LENGTH, CHANNELS))
        # process_list(sub_list, OUTPUT_DIR2, SIDE_LENGTH, CHANNELS)

    print("Processing...")
    # Start, do the work, and wait for results
    pool.close()
    pool.join()

    end = time.perf_counter()

    print(f"Conversion time: {end - start:.6f}s")
