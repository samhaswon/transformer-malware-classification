# pylint: disable=missing-module-docstring
import os
import re
from typing import List, Union, TYPE_CHECKING

# @see https://www.capstone-engine.org/lang_python.html
from capstone import Cs, CS_ARCH_X86, CS_MODE_32, CS_MODE_64
# @see https://github.com/erocarrera/pefile/blob/wiki/UsageExamples.md#introduction
from pefile import PE


# Global variables for input and output directories
INPUT_DIR1 = "loop_code/finite"
INPUT_DIR2 = "loop_code/infinite"
OUTPUT_DIR1 = "features/finite"
OUTPUT_DIR2 = "features/infinite"


class Disassembler:
    """
    Function definitions and member variable declarations for the Disassembler class.

    Converting executable code back into its assembly representation requires the implementation
    of a disassembler. The Disassembler class not only provides an interface to pull readable
    instructions from machine code, but it also allows for some very basic manipulation of the
    instructions.
    """
    # pylint: disable=too-many-instance-attributes
    def __init__(self, input_file: str) -> None:
        """
        Class initializer called when a new Disassembler is instantiated.
        :param input_file: The target executable file to be associated with the class instance.
        """
        ##
        # @var _executable_name
        # File name of target executable for Disassembler instance.
        #
        self._executable_name: str = input_file

        ##
        # @var _executable
        # PE abstracted from the binary file using the `pefile` package.
        #
        self._executable: PE = PE(self._executable_name, fast_load=True)

        ##
        # @var _disassembler
        # Capstone disassembling object for converting machine code to assembly.
        #
        self._disassembler: Cs = Cs(CS_ARCH_X86, CS_MODE_64)

        ##
        # @var _text_section_start
        # Virtual address for the starting position of the .text section.
        #
        self._text_section_start: int = 0

        ##
        # @var _text_section_end
        # Virtual address for the ending position of the .text section.
        #
        self._text_section_end: int = 0

        ##
        # @var _disasm_data
        # Sequence of disassembled machine code stored in a linear list.
        #
        self._disasm_data: List[str] = []

        # Code to set up class
        self.get_text_section()
        self.disassemble()

        if TYPE_CHECKING:
            self.text_section_end = None
            self.text_section_start = None

    def get_text_section(self) -> None:
        """
        Locates the .text section of an executable file and calculates its virtual starting and
        ending positions. In Windows PE files, the .text section is typically used to store
        executable code. The virtual address and size of each section within a file must be known
        by Windows beforehand, and, therefore, those values are stored within the file itself. It
        is necessary to obtain these values to know where code that can be meaningfully
        disassembled starts and ends within the binary stream of data.
        :return:
        """
        for section in self._executable.sections:
            # Linearly search for the 8-byte name of the .text section
            if section.Name == b".text\0\0\0":
                self.text_section_start = section.VirtualAddress
                self.text_section_end = section.VirtualAddress + section.Misc_VirtualSize

    def disassemble(self, include_address: bool = False) -> None:
        """
        Converts executable machine code to human-readable assembly.
        Requires that the virtual address and size of the .text section of the executable has been
        calculated using get_text_section

        Converting machine code to assembly requires the usage of a disassembler. Instructions
        must be read in and the appropriate number of operand bytes obtained before the conversion
        of binary data to text can occur. The Capstone engine is implemented to facilitate this
        process and making handling different architectures and word sizes easier to do.

        :param include_address: Flag used to determine if the virtual address of the instruction
        should be included with the mnemonic and operands.
        :return: None, Disassembled code is stored in the disasmData list as a set of strings.
        """
        # Pull the executable code from the PE file
        exe_code = self._executable.get_memory_mapped_image()[
                   self.text_section_start:self.text_section_end
                   ]
        # Get the entry point virtual address to ensure the correct address offset appears
        ep_virtual_address = self._executable.OPTIONAL_HEADER.ImageBase + self.text_section_start
        # Iterate over machine code and convert to assembly
        for instruction in self._disassembler.disasm(exe_code, ep_virtual_address):
            if include_address:
                self._disasm_data.append(
                    f"{hex(instruction.address)}: {instruction.mnemonic} "
                    f"{instruction.op_str.replace(' ', '')}"
                )
            else:
                self._disasm_data.append(
                    f"{instruction.mnemonic} {instruction.op_str.replace(' ', '')}"
                )

    def dump_assembly(self, output_file: str = "out.asm") -> None:
        """
        Dumps assembly code into a text file.
        :param output_file: Output file destination file to store the text data for future use.
        :return: Assembly code can be stored on the disk as a text file for future access or usage
        by another program. Each instruction and its operands are given a single line in the output
        file.
        """
        with open(output_file, "w+", encoding="utf-8") as dis_asm_write:
            for instruction in self._disasm_data:
                dis_asm_write.write(f"{instruction}\n")

    def print_report(self) -> None:
        """
        Prints the information presented by `pefile.PE.dump_info()` to stdout.
        :return: None
        """
        print(self._executable.dump_info())


def create_output_directories() -> None:
    """
    Creates the output directories if they do not already exist.
    """
    os.makedirs(OUTPUT_DIR1, exist_ok=True)
    os.makedirs(OUTPUT_DIR2, exist_ok=True)


def extract_text_section(input_path: str, output_path: str) -> None:
    """
    Extract the text section of the binary at `input_path` and dump it to `output_path`
    :param input_path: Path to the input executable file.
    :param output_path: Path to the output executable file.
    :return: None
    """
    # Open the file to prepare for processing
    executable_file = PE(input_path, fast_load=True)
    text_section: Union[str, None] = None

    # Find the .text section
    for section in executable_file.sections:
        if b'.text' in section.Name:
            text_section = section
            break

    # Dump the .text section
    if text_section:
        text_section_data = text_section.get_data()
        with open(output_path, "wb") as bytes_out:
            bytes_out.write(text_section_data)
    else:
        raise RuntimeError(f"Unable to extract the .text section of {input_path}")



def find_exe_files(directory) -> List[str]:
    """
    Finds all .exe files in the specified directory
    :param directory: The directory path to search in.
    :returns: A list of full paths to the .exe files found.
    """
    exe_pattern = re.compile(r".*\.exe$", re.IGNORECASE)  # Regex to match .exe files

    # Using scandir and list comprehension to collect .exe files
    exe_files = [
        entry.path for entry in os.scandir(directory)
        if entry.is_file() and exe_pattern.match(entry.name)
    ]

    return exe_files


if __name__ == "__main__":
    # Ensure output directories are created
    create_output_directories()

    # Find all .exe files in the input directories
    input_file_list_a = find_exe_files(INPUT_DIR1)
    input_file_list_b = find_exe_files(INPUT_DIR2)

    # Print the found .exe files from each directory
    print(f"Found {len(input_file_list_a)} .exe files in {INPUT_DIR1}:")
    for file in input_file_list_a:
        print(file)

    print(f"\nFound {len(input_file_list_b)} .exe files in {INPUT_DIR2}:")
    for file in input_file_list_b:
        print(file)

    for file_path in input_file_list_a:
        extract_text_section(
            file_path,
            OUTPUT_DIR1 + file_path[file_path.rfind(os.path.sep):file_path.rfind(".")] + ".bin"
        )
        # disassembler = Disassembler(file_path)
        # disassembler.dump_assembly(
        #     OUTPUT_DIR1 + file_path[file_path.rfind(os.path.sep):file_path.rfind(".")] + ".asm"
        # )

    for file_path in input_file_list_b:
        extract_text_section(
            file_path,
            OUTPUT_DIR2 + file_path[file_path.rfind(os.path.sep):file_path.rfind(".")] + ".bin"
        )
        # disassembler = Disassembler(file_path)
        # disassembler.dump_assembly(
        #     OUTPUT_DIR1 + file_path[file_path.rfind(os.path.sep):file_path.rfind(".")] + ".asm"
        # )
