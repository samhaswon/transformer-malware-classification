# pylint: disable=missing-module-docstring
import os
import re
from typing import List, Union, TYPE_CHECKING

# @see https://www.capstone-engine.org/lang_python.html
from capstone import Cs, CS_ARCH_X86, CS_MODE_32, CS_MODE_64
# @see https://github.com/erocarrera/pefile/blob/wiki/UsageExamples.md#introduction
from pefile import PE


# Global variables for input and output directories
INPUT_DIR1 = "loop_code/finite"
INPUT_DIR2 = "loop_code/infinite"
OUTPUT_DIR1 = "features/finite"
OUTPUT_DIR2 = "features/infinite"


def create_output_directories() -> None:
    """
    Creates the output directories if they do not already exist.
    """
    os.makedirs(OUTPUT_DIR1, exist_ok=True)
    os.makedirs(OUTPUT_DIR2, exist_ok=True)


def extract_text_section(input_path: str, output_path: str) -> None:
    """
    Extract the text section of the binary at `input_path` and dump it to `output_path`
    :param input_path: Path to the input executable file.
    :param output_path: Path to the output executable file.
    :return: None
    """
    # Open the file to prepare for processing
    executable_file = PE(input_path, fast_load=True)
    text_section: Union[str, None] = None

    # Find the .text section
    for section in executable_file.sections:
        if b'.text' in section.Name:
            text_section = section
            break

    # Dump the .text section
    if text_section:
        text_section_data = text_section.get_data()
        with open(output_path, "wb") as bytes_out:
            bytes_out.write(text_section_data)
    else:
        raise RuntimeError(f"Unable to extract the .text section of {input_path}")



def find_exe_files(directory) -> List[str]:
    """
    Finds all .exe files in the specified directory
    :param directory: The directory path to search in.
    :returns: A list of full paths to the .exe files found.
    """
    exe_pattern = re.compile(r".*\.exe$", re.IGNORECASE)  # Regex to match .exe files

    # Using scandir and list comprehension to collect .exe files
    exe_files = [
        entry.path for entry in os.scandir(directory)
        if entry.is_file() and exe_pattern.match(entry.name)
    ]

    return exe_files


if __name__ == "__main__":
    # Ensure output directories are created
    create_output_directories()

    # Find all .exe files in the input directories
    input_file_list_a = find_exe_files(INPUT_DIR1)
    input_file_list_b = find_exe_files(INPUT_DIR2)

    # Print the found .exe files from each directory
    print(f"Found {len(input_file_list_a)} .exe files in {INPUT_DIR1}:")
    for file in input_file_list_a:
        print(file)

    print(f"\nFound {len(input_file_list_b)} .exe files in {INPUT_DIR2}:")
    for file in input_file_list_b:
        print(file)

    for file_path in input_file_list_a:
        extract_text_section(
            file_path,
            OUTPUT_DIR1 + file_path[file_path.rfind(os.path.sep):file_path.rfind(".")] + ".bin"
        )
        # disassembler = Disassembler(file_path)
        # disassembler.dump_assembly(
        #     OUTPUT_DIR1 + file_path[file_path.rfind(os.path.sep):file_path.rfind(".")] + ".asm"
        # )

    for file_path in input_file_list_b:
        extract_text_section(
            file_path,
            OUTPUT_DIR2 + file_path[file_path.rfind(os.path.sep):file_path.rfind(".")] + ".bin"
        )
        # disassembler = Disassembler(file_path)
        # disassembler.dump_assembly(
        #     OUTPUT_DIR1 + file_path[file_path.rfind(os.path.sep):file_path.rfind(".")] + ".asm"
        # )
